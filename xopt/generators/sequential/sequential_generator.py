import numpy as np
from xopt.generator import Generator
import pandas as pd

class SequentialGenerator(Generator):
    """
    A generator that runs a sequential optimization algorithm, such as nelder mead, extremum seeking, rcds etc.

    Generally these algorithms need a internal state to keep track of the optimization process.
    Additionally, users cannot interrupt the optimization process to add new points.
    These algorithms will start from the last point in the history.

    """

    is_active: bool = False
    _last_candidate: dict = None

    def add_data(self, new_data):
        """
        Add new data to the generator.
        Args:
            new_data: The new data to add.
        """
        # if the generator is active then the new data must contain the last candidate
        if self.is_active:
            if self._last_candidate is None:
                raise ValueError(
                    "Generator is active, but no candidate was generated. Cannot add data."
                )
            # check if the last candidate is in the new data

            last_candidate = np.array([self._last_candidate[0][ele] for ele in self.vocs.variable_names])
            new_data_variables = new_data[self.vocs.variable_names].to_numpy().flatten()
            if not np.allclose(last_candidate, new_data_variables):
                raise ValueError(
                    "Cannot add data that was not generated by the generator when generator is active."\
                    "Call reset() to reset the generator."
                )

        super().add_data(new_data)

    def generate(self, n_candidates: int = 1):
        """
        Generate a new candidate point.
        Args:
            n_candidates: Number of candidates to generate.
        Returns:
            candidates: A list of candidate points.
        """

        # we cannot generate more than one candidate at a time
        if n_candidates > 1:
            raise ValueError(
                "Sequential generators can only generate one candidate at a time."
            )

        # if the generator is not active, we need to start it
        if not self.is_active:
            self.reset()
            self.is_active = True        

        candidate = self._generate()

        # need to store the candidate to validate adding data to the generator
        self._last_candidate = candidate

        return candidate
    
    def _generate(self):
        """
        Generate a new candidate point.
        Returns:
            candidate: A candidate point.
        """
        raise NotImplementedError("Sequential generators must implement _generate method.")
    
    def reset(self):
        """
        Reset the generator.
        """
        self.is_active = False
        self._last_candidate = None
        self._reset()
    
    def _reset(self):
        """
        Reset the generator.
        """
        raise NotImplementedError("Sequential generators must implement _reset method.")
    
    def _get_initial_point(self):
        # get the initial x0 value from data
        if self.data is None or len(self.data) == 0:
            raise ValueError(
                f"At least one point is required to start {self.__class__.__name__}, add data manually or via Xopt.random_evaluate() or Xopt.evaluate_data()"
            )
        return self.data.iloc[-1][self.vocs.variable_names].to_numpy(dtype=float)
